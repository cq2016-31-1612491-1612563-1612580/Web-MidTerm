"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A passport.js strategy for GOV.UK Verify
 */
/** */
const passport_strategy_1 = require("passport-strategy");
const saml_form_1 = require("./saml-form");
const verify_service_provider_client_1 = require("./verify-service-provider-client");
const translated_response_body_1 = require("./verify-service-provider-api/translated-response-body");
/**
 * A passport.js strategy for GOV.UK Verify
 *
 * ```
 * passport.use(passportVerifyStrategy)
 * ```
 *
 * Users of `passport-verify` should use [[createStrategy]] to create
 * instances of `PassportVerifyStrategy` rather than calling the constructor directly.
 */
class PassportVerifyStrategy extends passport_strategy_1.Strategy {
    constructor(client, createUser, verifyUser, handleIdentity, saveRequestId, loadRequestId, serviceEntityId, samlFormTemplateName, levelOfAssurance = 'LEVEL_2') {
        super();
        this.client = client;
        this.createUser = createUser;
        this.verifyUser = verifyUser;
        this.handleIdentity = handleIdentity;
        this.saveRequestId = saveRequestId;
        this.loadRequestId = loadRequestId;
        this.serviceEntityId = serviceEntityId;
        this.samlFormTemplateName = samlFormTemplateName;
        this.levelOfAssurance = levelOfAssurance;
        this.name = 'verify';
    }
    authenticate(req, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._handleRequest(req);
            }
            catch (error) {
                this.error(error);
            }
        });
    }
    success(user, info) { throw new Error('`success` should be overridden by passport'); }
    fail(challenge, status) { throw new Error('`fail` should be overridden by passport'); }
    error(reason) { throw reason; }
    _handleRequest(req) {
        if (req.body && req.body.SAMLResponse) {
            return this._translateResponse(req);
        }
        else {
            return this._renderAuthnRequest(req);
        }
    }
    _translateResponse(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestId = this.loadRequestId(req);
            const samlResponse = req.body.SAMLResponse;
            const response = yield this.client.translateResponse(samlResponse, requestId, this.levelOfAssurance, this.serviceEntityId);
            switch (response.status) {
                case 200:
                    if (response.body.scenario === translated_response_body_1.Scenario.IDENTITY_VERIFIED) {
                        yield this._handleSuccessResponse(response.body);
                    }
                    else {
                        yield this._handleSuccessMatchingResponse(response.body);
                    }
                    break;
                case 400:
                case 422:
                case 500:
                    throw new Error(response.body.message);
                default:
                    throw new Error(`Unexpected status ${response.status}`);
            }
        });
    }
    _handleSuccessResponse(responseBody) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (responseBody.scenario) {
                case translated_response_body_1.Scenario.IDENTITY_VERIFIED:
                    yield this._handleIdentity(responseBody, this.handleIdentity);
                    break;
                default:
                    this.fail(responseBody.scenario);
            }
        });
    }
    _handleSuccessMatchingResponse(responseBody) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (responseBody.scenario) {
                case translated_response_body_1.Scenario.ACCOUNT_CREATION:
                    yield this._verifyUser(responseBody, this.createUser);
                    break;
                case translated_response_body_1.Scenario.SUCCESS_MATCH:
                    yield this._verifyUser(responseBody, this.verifyUser);
                    break;
                default:
                    this.fail(responseBody.scenario);
            }
        });
    }
    _verifyUser(responseBody, fetchUser) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield fetchUser(responseBody);
            if (user) {
                this.success(user, responseBody);
            }
            else {
                this.fail(translated_response_body_1.Scenario.REQUEST_ERROR);
            }
            return Promise.resolve();
        });
    }
    _handleIdentity(responseBody, handleIdentity) {
        return __awaiter(this, void 0, void 0, function* () {
            const identity = yield handleIdentity(responseBody);
            if (identity) {
                this.success(identity, responseBody);
            }
            else {
                this.fail(translated_response_body_1.Scenario.REQUEST_ERROR);
            }
            return Promise.resolve();
        });
    }
    _renderAuthnRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const authnRequestResponse = yield this.client.generateAuthnRequest(this.levelOfAssurance, this.serviceEntityId);
            if (authnRequestResponse.status === 200) {
                const authnRequestResponseBody = authnRequestResponse.body;
                this.saveRequestId(authnRequestResponseBody.requestId, request);
                const response = request.res;
                if (this.samlFormTemplateName) {
                    return response.render(this.samlFormTemplateName, { ssoLocation: authnRequestResponseBody.ssoLocation, samlRequest: authnRequestResponseBody.samlRequest });
                }
                else {
                    return response.send(saml_form_1.createSamlForm(authnRequestResponseBody.ssoLocation, authnRequestResponseBody.samlRequest));
                }
            }
            else {
                const errorBody = authnRequestResponse.body;
                throw new Error(errorBody.message);
            }
        });
    }
}
exports.PassportVerifyStrategy = PassportVerifyStrategy;
/**
 * Creates an instance of [[PassportVerifyStrategy]]
 *
 * This version of the function should only be used if your service uses the legacy setup. A legacy setup
 * involves connecting to GOV.UK Verify with a Matching Service Adapter (MSA).
 *
 * @param verifyServiceProviderHost The URL that the Verify Service Provider is running on (e.g. http://localhost:50400)
 * @param createUser A callback that will be invoked when a response with a new user is received.
 * The `user` object will contain the users' attributes (i.e. firstName, surname etc.).
 * Your callback should store details of the user in your datastore and return an object representing the user.
 * @param verifyUser A callback that will be invoked when a response with a matched user is received.
 * Your callback should look the user up in your datastore using their `pid` (persistent identitfier)
 * and return an object representing the user.
 * @param saveRequestId A callback that will be invoked to save the requestId that has been generated by
 * the verify service provider. Your callback should save the request Id in a secure manner so that it
 * can be matched against the corresponding SAML response.
 * @param loadRequestId A callback that will be invoked to load the requestId that has been securely saved
 * for the user's session.
 * @param serviceEntityId (Optional) The entityId that will be passed to the Verify Service Provider. This is
 * only required if the service provider is configured to be multi tenanted.
 * @param samlFormTemplateName (Optional) The name of a template in your service which will provide the form
 * used to post an authn request. If present, this will be rendered with the ssoLocation and samlRequest passed
 * in. Otherwise, a default form will be used. You should use this option if you wish to style the form, which
 * should be autoposting so only seen if the user has javascript disabled, to match the rest of your service.
 * @param levelOfAssurance (Optional) LEVEL_1 or LEVEL_2 - defaults to LEVEL_2. The Level of Assurance to
 * request from the Verify Service Provider and the minimum level to expect in the Response (e.g. if you
 * specify LEVEL_1 a LEVEL_2 Response would also be permissible).
 * @returns A strategy to be registered in passport with
 * ```
 * passport.use(passportVerifyStrategy)
 * ```
 */
function createStrategy(verifyServiceProviderHost, createUser, verifyUser, saveRequestId, loadRequestId, serviceEntityId, samlFormTemplateName, levelOfAssurance) {
    const client = new verify_service_provider_client_1.default(verifyServiceProviderHost);
    return new PassportVerifyStrategy(client, createUser, verifyUser, () => undefined, saveRequestId, loadRequestId, serviceEntityId, samlFormTemplateName, levelOfAssurance);
}
exports.createStrategy = createStrategy;
/**
 * Creates an instance of [[PassportVerifyStrategy]]
 *
 * This version of the function should only be used if your service connects to GOV.UK Verify using the
 * Verify Service Provider (VSP) without a Matching Service Adapter (MSA).
 *
 * @param verifyServiceProviderHost The URL that the Verify Service Provider is running on (e.g. http://localhost:50400)
 * @param handleIdentity A callback that will be invoked when a response with an identity is received.
 * The `identity` object will contain the users' attributes (i.e. firstName, surname etc.).
 * Your callback should store details of the user in your datastore and return an object representing the user.
 * @param saveRequestId A callback that will be invoked to save the requestId that has been generated by
 * the verify service provider. Your callback should save the request Id in a secure manner so that it
 * can be matched against the corresponding SAML response.
 * @param loadRequestId A callback that will be invoked to load the requestId that has been securely saved
 * for the user's session.
 * @param serviceEntityId (Optional) The entityId that will be passed to the Verify Service Provider. This is
 * only required if the service provider is configured to be multi tenanted.
 * @param samlFormTemplateName (Optional) The name of a template in your service which will provide the form
 * used to post an authn request. If present, this will be rendered with the ssoLocation and samlRequest passed
 * in. Otherwise, a default form will be used. You should use this option if you wish to style the form, which
 * should be autoposting so only seen if the user has javascript disabled, to match the rest of your service.
 * @param levelOfAssurance (Optional) LEVEL_1 or LEVEL_2 - defaults to LEVEL_2. The Level of Assurance to
 * request from the Verify Service Provider and the minimum level to expect in the Response (e.g. if you
 * specify LEVEL_1 a LEVEL_2 Response would also be permissible).
 * @returns A strategy to be registered in passport with
 * ```
 * passport.use(passportVerifyStrategy)
 * ```
 */
function createIdentityStrategy(verifyServiceProviderHost, handleIdentity, saveRequestId, loadRequestId, serviceEntityId, samlFormTemplateName, levelOfAssurance) {
    const client = new verify_service_provider_client_1.default(verifyServiceProviderHost);
    return new PassportVerifyStrategy(client, () => undefined, () => undefined, handleIdentity, saveRequestId, loadRequestId, serviceEntityId, samlFormTemplateName, levelOfAssurance);
}
exports.createIdentityStrategy = createIdentityStrategy;
