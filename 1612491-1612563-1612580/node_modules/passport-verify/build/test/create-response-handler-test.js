"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const create_response_handler_1 = require("../lib/create-response-handler");
const translated_response_body_1 = require("../lib/verify-service-provider-api/translated-response-body");
const td = require("testdouble");
function verifyNotCalled(fn) {
    td.verify(fn(), { times: 0, ignoreExtraArgs: true });
}
describe('The createResponseHandler function', () => {
    let scenarios;
    let onMatch;
    let onCreateUser;
    let onAuthnFailed;
    let onNoMatch;
    let onCancel;
    let onError;
    beforeEach(() => {
        onMatch = td.function();
        onCreateUser = td.function();
        onAuthnFailed = td.function();
        onNoMatch = td.function();
        onCancel = td.function();
        onError = td.function();
        scenarios = {
            onMatch,
            onCreateUser,
            onAuthnFailed,
            onNoMatch,
            onCancel,
            onError
        };
    });
    it('should return a passport authenticate callback function', () => {
        const result = create_response_handler_1.createResponseHandler(scenarios);
        assert.strictEqual(typeof result, 'function');
        assert.strictEqual(result.length, 4);
    });
    it('callback should call onMatch when called with an existing user', () => {
        const error = null;
        const user = {};
        const info = { scenario: translated_response_body_1.Scenario.SUCCESS_MATCH, pid: '', levelOfAssurance: '' };
        const status = null;
        create_response_handler_1.createResponseHandler(scenarios)(error, user, info, status);
        td.verify(onMatch(user));
        verifyNotCalled(onCreateUser);
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onNoMatch);
        verifyNotCalled(onCancel);
        verifyNotCalled(onError);
    });
    it('callback should call onCreateUser when called with an new user', () => {
        const error = null;
        const user = {};
        const info = { scenario: translated_response_body_1.Scenario.ACCOUNT_CREATION, pid: '', levelOfAssurance: '', attributes: {} };
        const status = null;
        create_response_handler_1.createResponseHandler(scenarios)(error, user, info, status);
        td.verify(onCreateUser(user));
        verifyNotCalled(onMatch);
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onNoMatch);
        verifyNotCalled(onCancel);
        verifyNotCalled(onError);
    });
    it('callback should call onAuthnFailed when called with no user and no error', () => {
        const error = null;
        const user = null;
        const info = translated_response_body_1.Scenario.AUTHENTICATION_FAILED;
        const status = null;
        create_response_handler_1.createResponseHandler(scenarios)(error, user, info, status);
        td.verify(onAuthnFailed());
        verifyNotCalled(onMatch);
        verifyNotCalled(onCreateUser);
        verifyNotCalled(onNoMatch);
        verifyNotCalled(onCancel);
        verifyNotCalled(onError);
    });
    it('callback should call onNoMatch when called with no user, no error, and a NO_MATCH scenario', () => {
        const error = null;
        const user = null;
        const info = translated_response_body_1.Scenario.NO_MATCH;
        const status = null;
        create_response_handler_1.createResponseHandler(scenarios)(error, user, info, status);
        td.verify(onNoMatch());
        verifyNotCalled(onMatch);
        verifyNotCalled(onCreateUser);
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onCancel);
        verifyNotCalled(onError);
    });
    it('callback should call onCancel when called with no user, no error, and a CANCELLATION scenario', () => {
        const error = null;
        const user = null;
        const info = translated_response_body_1.Scenario.CANCELLATION;
        const status = null;
        create_response_handler_1.createResponseHandler(scenarios)(error, user, info, status);
        td.verify(onCancel());
        verifyNotCalled(onMatch);
        verifyNotCalled(onCreateUser);
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onNoMatch);
        verifyNotCalled(onError);
    });
    it('callback should call onError when called with no user, no error, and an inappropriate scenario', () => {
        const error = null;
        const user = null;
        const info = translated_response_body_1.Scenario.SUCCESS_MATCH;
        const status = null;
        create_response_handler_1.createResponseHandler(scenarios)(error, user, info, status);
        td.verify(onError(new Error('Unrecognised Scenario SUCCESS_MATCH')));
        verifyNotCalled(onMatch);
        verifyNotCalled(onCreateUser);
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onNoMatch);
        verifyNotCalled(onCancel);
    });
    it('callback should call onError when called with no user, no error, and a REQUEST_ERROR info', () => {
        const error = null;
        const user = null;
        const info = translated_response_body_1.Scenario.REQUEST_ERROR;
        const status = null;
        create_response_handler_1.createResponseHandler(scenarios)(error, user, info, status);
        td.verify(onError(new Error('SAML Response was an error')));
        verifyNotCalled(onMatch);
        verifyNotCalled(onCreateUser);
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onNoMatch);
        verifyNotCalled(onCancel);
    });
    it('callback should call onError when called with an error', () => {
        const error = new Error('some-really-bad-error');
        const user = null;
        const info = null;
        const status = null;
        create_response_handler_1.createResponseHandler(scenarios)(error, user, info, status);
        td.verify(onError(error));
        verifyNotCalled(onMatch);
        verifyNotCalled(onCreateUser);
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onNoMatch);
        verifyNotCalled(onCancel);
    });
});
