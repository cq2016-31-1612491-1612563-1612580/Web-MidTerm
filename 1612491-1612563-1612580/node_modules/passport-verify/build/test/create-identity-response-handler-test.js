"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const create_identity_response_handler_1 = require("../lib/create-identity-response-handler");
const translated_response_body_1 = require("../lib/verify-service-provider-api/translated-response-body");
const td = require("testdouble");
function verifyNotCalled(fn) {
    td.verify(fn(), { times: 0, ignoreExtraArgs: true });
}
describe('The createIdentityResponseHandler function', () => {
    let scenarios;
    let onIdentityVerified;
    let onAuthnFailed;
    let onNoAuthentication;
    let onError;
    beforeEach(() => {
        onIdentityVerified = td.function();
        onAuthnFailed = td.function();
        onNoAuthentication = td.function();
        onError = td.function();
        scenarios = {
            onIdentityVerified,
            onAuthnFailed,
            onNoAuthentication,
            onError
        };
    });
    it('should return a passport authenticate callback function', () => {
        const result = create_identity_response_handler_1.createIdentityResponseHandler(scenarios);
        assert.strictEqual(typeof result, 'function');
        assert.strictEqual(result.length, 4);
    });
    it('callback should call onMatch when called with an existing user', () => {
        const error = null;
        const identity = {};
        const info = { scenario: translated_response_body_1.Scenario.IDENTITY_VERIFIED, pid: '', levelOfAssurance: '' };
        const status = null;
        create_identity_response_handler_1.createIdentityResponseHandler(scenarios)(error, identity, info, status);
        td.verify(onIdentityVerified(identity));
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onNoAuthentication);
        verifyNotCalled(onError);
    });
    it('callback should call onAuthnFailed when called with no user and no error', () => {
        const error = null;
        const identity = null;
        const info = translated_response_body_1.Scenario.AUTHENTICATION_FAILED;
        const status = null;
        create_identity_response_handler_1.createIdentityResponseHandler(scenarios)(error, identity, info, status);
        td.verify(onAuthnFailed());
        verifyNotCalled(onIdentityVerified);
        verifyNotCalled(onNoAuthentication);
        verifyNotCalled(onError);
    });
    it('callback should call onNoAuthentication when called with no user, no error, and a NO_AUTHENTICATION scenario', () => {
        const error = null;
        const identity = null;
        const info = translated_response_body_1.Scenario.NO_AUTHENTICATION;
        const status = null;
        create_identity_response_handler_1.createIdentityResponseHandler(scenarios)(error, identity, info, status);
        td.verify(onNoAuthentication());
        verifyNotCalled(onIdentityVerified);
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onError);
    });
    it('callback should call onError when called with no user, no error, and an inappropriate scenario', () => {
        const error = null;
        const identity = null;
        const info = translated_response_body_1.Scenario.SUCCESS_MATCH;
        const status = null;
        create_identity_response_handler_1.createIdentityResponseHandler(scenarios)(error, identity, info, status);
        td.verify(onError(new Error('Unrecognised Scenario SUCCESS_MATCH')));
        verifyNotCalled(onIdentityVerified);
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onNoAuthentication);
    });
    it('callback should call onError when called with no user, no error, and a REQUEST_ERROR info', () => {
        const error = null;
        const identity = null;
        const info = translated_response_body_1.Scenario.REQUEST_ERROR;
        const status = null;
        create_identity_response_handler_1.createIdentityResponseHandler(scenarios)(error, identity, info, status);
        td.verify(onError(new Error('SAML Response was an error')));
        verifyNotCalled(onIdentityVerified);
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onNoAuthentication);
    });
    it('callback should call onError when called with an error', () => {
        const error = new Error('some-really-bad-error');
        const identity = null;
        const info = null;
        const status = null;
        create_identity_response_handler_1.createIdentityResponseHandler(scenarios)(error, identity, info, status);
        td.verify(onError(error));
        verifyNotCalled(onIdentityVerified);
        verifyNotCalled(onAuthnFailed);
        verifyNotCalled(onNoAuthentication);
    });
});
